	 프로시저, 메소드, 루틴

### 함수 기초
	input으로 무엇을 받고, output으로 무엇을 뱉을지 정해준다.

- 예제
```cpp
#include <iostream>
using namespace std;

/*
* 반환타입 함수이름([인자타입 매개변수])
* {
*	함수 내용
* 
*	return ~
* }
*/

// Hello World를 출력하는 함수를 만들어보자!
// input : 없음 / output : 없음
// 타입 : int float double char ... void

void PrintHelloWorld()
{
	cout << "Hello World" << endl;
}

void PrintNumber(int number)
{
	cout << "넘겨주신 숫자는 " << number << " 입니다" << endl;
}

int MultiplyTwo(int number)
{
	int result = number * 2;
	return result;
}

int MultiplyBy(int a, int b)
{
	int result = a * b;
	return result;
}

int main()
{
	PrintHelloWorld();
	int num = MultiplyBy(3,5);
	PrintNumber(num);
}
```

### 스택 프레임
![[Pasted image 20250721133200.png]]

### 지역 변수와 값 전달
- 지역 변수
	- 어떤 함수 내부에 만든 변수
	- 스택 영역에 저장됨  
- 전역 변수
	- 데이터 영역에 저장됨

### 호출 스택
#### 함수 선언
C++은 C#과 다르게 함수가 호출될 때, 그 함수가 선언되어 있지 않으면 에러가 난다. 그래서 함수를 미리 선언해둔다. 미리 선언만 해두면 구현은 아무데나 해놔도 된다. 물론 구현을 해두긴 해야 한다.
```cpp
#include <iostream>
using namespace std;

void Func1();
void Func2(int hp, int mp);
void Func3(float);

void Func1()
{
	cout << "Func1" << endl;
	Func2(1,2);
}

void Func2(int a, int b)
{
	cout << "Func2" << endl;
	Func3(10);
}

void Func3(float a)
{
	cout << "Func3" << endl;
}


int main()
{
	cout << "main" << endl;
	Func1();
}
```
그래서 호출 스택이 뭐냐?

#### 호출 스택
앞서 함수가 호출되면 스택 메모리에 {매개변수} - {반환 주소값(RET)} - { 지역변수} 순으로 저장되는 것을 배웠다. 함수 안에서 함수가 호출되면 같은 방식으로 스택 메모리에 필요한 정보가 저장된다. 이것이 바로 호출 스택(Call Stack)이다. 가장 마지막에 호출된 함수가 먼저 실행되어 제거된다. 이게 계속되면 영화 "인셉션"처럼 지금 내가 어디 있는지 굉장히 혼란스러운 순간이 올 것인데, 디버깅 시 호출 스택을 잘 활용하도록 하자.
![[Pasted image 20250722123127.png]]

