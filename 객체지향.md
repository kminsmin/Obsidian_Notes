### 객체지향의 시작
```cpp
#include <iostream>

using namespace std;

class Knight
{
public :
	void Attack();
	void Move(int x, int y);
	void Die();
	
	int hp;
	int atk;
	int posX;
	int posY;
};

int main()
{
	Knight k1;
	Knight k2;
	
	k1.Attack();
	k1.Move(1,2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << atk << endl;
}

void Knight::Move(int x, int y)
{
	posX = x;
	posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	hp = 0;
	cout << "Die" << endl;
}
```

### 생성자와 소멸자
	특별한 멤버함수 2가지
이전 시간에 클래스에서 멤버 함수, 멤버 변수 등을 만들었었다. 그런데 이 멤버 함수 중에서 특별한 친구들 2가지가 있는데, 그들이 바로 생성자와 소멸자이다.

#### 특징
- 생성자는 함수를 오버로딩 하는 것 처럼 여러개 만들 수 있다.
- 소멸자는 한 개만 만들 수 있다.
- 생성자를 명시적(explicit)으로 만들어두지 않으면, 컴파일러가 아무 인자도 받지 않는 생성자를 만드는데 이를 암시적(implicit) 생성자라 한다.
```cpp
#include <iostream>

using namespace std;

//class 는 일종의 설계도
class Knight
{
public:
	// [1] 기본 생성자 (인자가 없음)
	Knight()
	{
		cout << "Knight() 생성자 호출" << endl;
		_hp = 100;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// [2] 복사 생성자 (자기 자신의 클래스 참조 타입을 인자로 받음)
	// (일반적으로 '똑같은' 데이터를 지닌 객체가 생성되길 기대한다)
	Knight(const Knight& knight)
	{
		_hp = knight._hp;
		_atk = knight._atk;
		_posX = knight._posX;
		_posY = knight._posY;
	}

	// [3] 기타 생성자
	// 이 중에서 인자를 1개만 받는 기타 생성자를
	// [타입 변환 생성자]라 한다.
	Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// 소멸자
	~Knight()
	{
		cout << "소멸자 호출" << endl;
	}


	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

int main()
{
	Knight k1;

	k1.Attack();
	k1.Move(1, 2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << _atk << endl;
}

void Knight::Move(int x, int y)
{
	_posX = x;
	_posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	_hp = 0;
	cout << "Die" << endl;
}
```

#### 주의사항
- 생성자가 하나라도 명시적으로 만들어져 있으면, 컴파일러는 ==기본 생성자==를 만들지 않는다.
	-  인자를 받는 생성자가 하나 있으면 컴파일러는 기본 생성자를 만들지 않기 때문에, 아무 인자 없이 클래스를 만드는 게 불가능해진다. 이 경우 명시적으로 기본 생성자를 만들어주어야 한다.
- 사실 ==복사 생성자==도 명시적으로 만들어져 있지 않으면 컴파일러가 자동으로 만든다.
	- 단순 변수만 있으면 왜 굳이 명시적으로 만들어야 할까 싶긴 한데, 동적 할당을 배우면 필요가 있어진다고 한다.
```cpp
Knight k2 = Knight(k1);
Knight k3 = k1; //둘 다 같은 방식.

Knight k4;
k4 = k1; //이 경우 k4 객체가 먼저 만들어지고, 이후 k1의 모든 멤버 변수를 복사
```
- 인자를 한 개 받는 기타 생성자 : ==타입 변환 생성자==
```cpp
Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

--------------------
	Knight k1 = 1; // 암시적으로 타입 변환 생성자 호출
	Knight k2 = (Knight)2; // 명시적 형변환. 작동은 위와 같음.
```
위처럼 어떤 데이터 타입을 해당 클래스로 형변환할 때마다 호출되는 특별한 생성자가 된다. 근데 이런 캐스팅이 암시적으로 일어나면 혼란스럽기도 하고, 의도치 않은 버그가 발생할 수도 있다.  그래서 암시적 캐스팅을 막고 싶다면 ==explicit== 키워드를 추가하면 된다.
```cpp
explicit Knight(int hp)
{
//쏼라쏼라
}
```

### 상속성
	객체지향의 3가지 특징 : 상속성, 은닉성, 다형성

저번에 TextRPG를 만들 각 직업들을 struct를 통해 만들었었는데, 클래스로 만들어보자.
```cpp
class Knight
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

class Archer
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

class Mage
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};
```
겹치는 코드가 매우 많다. 이걸 간략하게 해결할 순 없을까?

#### 상속 (Inheritance)
```cpp
#include <iostream>

using namespace std;

class Player
{
public:
	Player() { cout << "Player() 기본 생성자 호출" << endl; }
	Player(int hp)
	{
		_hp = hp;
		_atk = 10;
		{ cout << "Player(int) 생성자 호출" << endl; }
	}
	~Player()
	{
		{ cout << "Player 소멸자 호출" << endl; }
	}
	// 멤버 함수 선언
	void Attack() { cout << "Player Attack 호출" << endl; }
	void Move() { cout << "Player Move 호출" << endl; }
	void Die() { cout << "Player Die 호출" << endl; }

public:
	// 멤버 변수
	int _hp;
	int _atk;
};

class Mage : public Player
{
public:

public:
	int _mp;
};
class Knight : public Player
{
public:
	Knight() { cout << "Knight() 기본 생성자 호출" << endl; }
	Knight(int stamina) : Player(100)
	/*
	* 선처리 영역
	* Player 생성자 호출
	*/
	{
		_stamina = stamina;
		{ cout << "Knight(int)생성자 호출" << endl; }
	}
	~Knight()
	{
		{ cout << "Knight 소멸자 호출" << endl; }
	}
	/*
	* 후처리 영역
	* Player 소멸자 호출
	*/

	// 함수 재정의
	void Move() { cout << "Knight Move 호출" << endl; }
public:
	int _stamina;
};

int main()
{
	Knight k1(10);
	k1.Move(); //재정의된 knight의 함수 호출
	k1.Player::Move(); //재정의로 인해 숨겨진 Player의 원본 함수 호출. 쓸일은 거의 없다.

	return 0;
}
```

###  은닉성
	Data Hiding, 캡슐화(Encapsulation). 몰라도 되는 것은 깔끔하게 숨기겠다!

#### 필요성
1. 정말 위험하고 건드리면 안되는 경우
```cpp
#include <iostream>

using namespace std;

// 자동차
// - 핸들
// - 페달
// - 엔진
// - 문
// - 각종 전기선

// 일반 구매자 입장에서 사용하는 것?
// - 핸들/페달/문
// 몰라도 됨 (오히려 건드리면 큰일남)
// - 엔진, 각종 전기선

// public protected private
// - public : 누구한테나 공개. 실컷 사용하세요~
// - protected : 나의 자손들한테만 허락
// - private : 나만 사용할거야. << class Car 내부에서만!

class Car
{
public: // (멤버) 접근지정자
	void MoveHandle() {}
	void PushPedal() {}
	void OpenDoor() {}

	void TurnKey()
	{
		// ....
		RunEngine();
	}
private:
	void DisassembleCar() {} // 차를 분해한다
	void ConnectCircuit() {} // 전기선 연결
protected:
	void RunEngine() {} // 엔진을 구동시킨다

public:
	// 핸들
	// 페달
	// 엔진
	// 문
	// 각종 전기선
};

class SuperCar : public Car // 상속 접근 지정자
{
public:
	void PushRemoteController()
	{
		RunEngine();
	}
};


int main()
{
	SuperCar car;
	car.OpenDoor();
	car.PushRemoteController();

	return 0;
}


```
2. 다른 경로로 접근하길 원하는 경우
```cpp
#include <iostream>

using namespace std;


// public protected private
// - public : 누구한테나 공개. 실컷 사용하세요~
// - protected : 나의 자손들한테만 허락
// - private : 나만 사용할거야. << class Car 내부에서만!

// '캡슐화'
// 연관된 데이터와 함수를 논리적으로 묶어놓은 것
class Berserker
{
public:
	// 사양 : 체력이 50 이하로 떨어지면 버서커 모드 발동 (강해짐)
	int GetHp() { return _hp; }
	void SetHp(int hp)
	{
		_hp = hp;
		if (_hp <= 50)
			SetBerserkerMode();
	}
private:
	void SetBerserkerMode()
	{
		cout << "매우 강해짐!" << endl;
	}

private :
	int _hp = 100;
};

int main()
{
	Berserker b;
	b.SetHp(20);

	return 0;
}
```

#### 상속 접근 지정자
	 다음 세대한테 부모님의 유산을 어떻게 물려줄지?
- `public` : 공개적 상속. 부모님의 유산 설계 그대로 (public -> public, protected -> protected)
- `protected` : 보호받은 상속. 내 자손들한테만 물려줄거야 (public -> protected, protected -> protected)
- `private` : 개인적인 상속. 나만 쓸거야 (public->private, protected ->private)
```cpp
class SuperCar : private Car // 상속 접근 지정자
{
public:
	void PushRemoteController()
	{
		RunEngine();
	}
};

class TestSuperCar : private SuperCar
{
public:
	void Test()
	{
		RunEngine();// 접근 못함. 에러남.
	}
}
```

###  다형성
	Polymorphism. 겉은 똑같은데, 기능이 다르게 동작한다.
	 오버로딩(Overloading) = 함수 중복 정의 = 함수 이름의 재사용
	 오버라이딩(Overriding) = 재정의 = 부모 클래스의 함수를 자식 클래스에서 정의

#### 바인딩 (Binding)
	함수와 주소를 매핑. 일반적인 함수(가상함수 외 모든 멤버 함수)는 정적 바인딩 
- 정적 바인딩 (Static Binding) : 컴파일  시점에 결정
- ==동적 바인딩 (Dynamic Binding) : 실행 시점(런타임)에 결정==

이전 시간에 Player 클래스를 상속받아서, Player의 Move 함수를 Knight에서 재정의하여 사용해본 적이 있다. 이런 경우 Knight의 Move를 직접 호출하는 경우는 문제가 없으나, 아래 함수를 만들어서 간접적으로 접근하게 되면 문제가 발생한다.
```cpp
class Player
{
public:
	void Move() { cout << "Move Player!" << endl; }
	void Move(int) { cout << "Move(int) Player!" << endl; } // 오버로딩

public:
	int _hp;
};

class Knight : public Player
{
public:
	void Move() { cout << "Move Knight!" << endl; }
public:
	int _stamina;
};

void MovePlayer(Player* player)
{
	player->Move();
}
int main()
{
	Knight k;
	MovePlayer(&k);
	return 0;
}
```
![[Pasted image 20250805123130.png]]
Knight의 주소를 넘겨줬음에도 불구하고  Player의 Move 함수가 실행되었다. 이는 대부분의 함수가 컴파일 단계에서  '정적 바인딩'되기 때문이다. 우리는 Knight의 Move가 실행되길 원한다. 그렇다면 정적 바인딩이 아닌, '동적 바인딩'을 사용하기 위해서는 어떻게 해야 할까?

#### 가상 함수 (Virtual Function)
	 주의 : 한번 가상 함수는, 그 뒤에 재정의를 해도 영원히 가상함수다!
	 재정의한 함수에 virtual을 붙이지 않아도 말이다.
```cpp
class Player
{
public:
	virtual void VMove() { cout << "Move Player!" << endl; } // 가상함수
	void Move(int) { cout << "Move(int) Player!" << endl; } // 오버로딩

public:
	int _hp;
};

class Knight : public Player
{
public:
	void VMove() { cout << "Move Knight!" << endl; } // 재정의했지만 여전히 가상함수
public:
	int _stamina;
};
```
위처럼 원본 함수는 `virtual` 키워드를 붙여서 가상함수로 만들고, 이를 Knight 클래스에서 재정의하여 위 코드의 MovePlayer 함수를 실행하면 어떻게 될까?
![[Pasted image 20250805123941.png]]
아름답게 Knight의 Move가 실행됨을 볼 수 있다. 그렇다면 동적 바인딩은 어떤 원리로 작동할까?
실제 객체가 어떤 타입인지 어떻게 알고 알아서 가상 함수를 호출해준걸까?
-> ==가상 함수 테이블 (vftable)==
- 부모의 가상 함수를 재정의하게 되면, 해당 자식 클래스의 객체가 생성 될 때, 멤버 변수들 말고도 `가상 함수 테이블`의 주소를 저장하는 포인터가 저장된다. 함수를 호출할 때면, 해당 포인터를 타고 가상 함수 테이블에 접근해서 적합한 가상 함수를 호출하는 원리이다. 가상 함수 테이블은 클래스마다 하나씩 생성된다. 컴파일 시 가상함수가 만들어진 클래스가 있다면 해당 클래스의 가상 함수 테이블이 만들어지며, 이는 rodata(read-only-data) 영역에 저장된다.

#### 그 외 알쓸신잡
- `abstract`. ==순수 가상함수==
	- 구현은 없고 '인터페이스'만 전달하는 용도로 사용하고 싶을 경우
```cpp
virtual void VMove() = 0;
virtual void VMove() abstract;
```
		이렇게 선언된 가상함수를 순수 가상함수라고 한다.

- 순수 가상함수가 하나라도 포함된 클래스는 "==추상 클래스=="로 간주한다.
- 추상 클래스로는 객체를 생성할 수 없다.

### 초기화 리스트
	 멤버 변수 초기화? 다양한 문법이 존재
	 그리고 초기화는 왜 해야 할까?
#### 초기화의 필요성
- 버그 예방에 중요
- 포인터 등 주소값이 연루되어 있을 경우

#### 초기화 방법
- 생성자 내에서
- ==초기화 리스트==
	- 일단 상속 관계에서 원하는 부모 생성자를 호출 할 때 필요.
	- 초기화 리스트 vs 생성자 내 초기화
		- 일반 변수는 별 차이 없음
		- 멤버 타입이 클래스인 경우 차이가 있음
			- 선처리 영역에서 멤버 클래스의 객체를 만들어버림
			- 이후 생성자 내에서 또 객체를 만들어서 초기화하면 선처리 영역에서 만든 객체는 소멸됨
			- 클래스 멤버를 초기화할 경우 그냥 초기화 리스트에서 하는게 낫다.
		- 정의함과 동시에 초기화가 필요한 경우 -> 초기화 리스트 필수
			- 참조 타입
			- const 타입
- C++11 문법
```cpp
class Player
{
public:
	Player() {}
	Player(int id) {}
};
class Inventory
{
public:
	Inventory() {cout<<"Inventory()"<<endl;}
	Inventory(int size)
	{
		_size = size;
		cout << "Inventory(int)" << endl;
	}
public:
	int _size;
};

class Knight : public Player
{
public:
	Knight() : Player(1), _hp(100), _inventory(20) // 초기화 리스트
	/*
	* 선처리 영역
	*/
	{
		_hp = 100; // 생성자 내에서 초기화
	}

public:
	int _hp;
	Inventory _inventory;
	int _stamina = 100; // 되게 최근 문법.
};
```