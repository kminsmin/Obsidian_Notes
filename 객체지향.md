### 객체지향의 시작
```cpp
#include <iostream>

using namespace std;

class Knight
{
public :
	void Attack();
	void Move(int x, int y);
	void Die();
	
	int hp;
	int atk;
	int posX;
	int posY;
};

int main()
{
	Knight k1;
	Knight k2;
	
	k1.Attack();
	k1.Move(1,2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << atk << endl;
}

void Knight::Move(int x, int y)
{
	posX = x;
	posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	hp = 0;
	cout << "Die" << endl;
}
```

### 생성자와 소멸자
	특별한 멤버함수 2가지
이전 시간에 클래스에서 멤버 함수, 멤버 변수 등을 만들었었다. 그런데 이 멤버 함수 중에서 특별한 친구들 2가지가 있는데, 그들이 바로 생성자와 소멸자이다.

#### 특징
- 생성자는 함수를 오버로딩 하는 것 처럼 여러개 만들 수 있다.
- 소멸자는 한 개만 만들 수 있다.
- 생성자를 명시적(explicit)으로 만들어두지 않으면, 컴파일러가 아무 인자도 받지 않는 생성자를 만드는데 이를 암시적(implicit) 생성자라 한다.
```cpp
#include <iostream>

using namespace std;

//class 는 일종의 설계도
class Knight
{
public:
	// [1] 기본 생성자 (인자가 없음)
	Knight()
	{
		cout << "Knight() 생성자 호출" << endl;
		_hp = 100;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// [2] 복사 생성자 (자기 자신의 클래스 참조 타입을 인자로 받음)
	// (일반적으로 '똑같은' 데이터를 지닌 객체가 생성되길 기대한다)
	Knight(const Knight& knight)
	{
		_hp = knight._hp;
		_atk = knight._atk;
		_posX = knight._posX;
		_posY = knight._posY;
	}

	// [3] 기타 생성자
	// 이 중에서 인자를 1개만 받는 기타 생성자를
	// [타입 변환 생성자]라 한다.
	Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// 소멸자
	~Knight()
	{
		cout << "소멸자 호출" << endl;
	}


	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

int main()
{
	Knight k1;

	k1.Attack();
	k1.Move(1, 2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << _atk << endl;
}

void Knight::Move(int x, int y)
{
	_posX = x;
	_posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	_hp = 0;
	cout << "Die" << endl;
}
```

#### 주의사항
- 생성자가 하나라도 명시적으로 만들어져 있으면, 컴파일러는 ==기본 생성자==를 만들지 않는다.
	-  인자를 받는 생성자가 하나 있으면 컴파일러는 기본 생성자를 만들지 않기 때문에, 아무 인자 없이 클래스를 만드는 게 불가능해진다. 이 경우 명시적으로 기본 생성자를 만들어주어야 한다.
- 사실 ==복사 생성자==도 명시적으로 만들어져 있지 않으면 컴파일러가 자동으로 만든다.
	- 단순 변수만 있으면 왜 굳이 명시적으로 만들어야 할까 싶긴 한데, 동적 할당을 배우면 필요가 있어진다고 한다.
```cpp
Knight k2 = Knight(k1);
Knight k3 = k1; //둘 다 같은 방식.

Knight k4;
k4 = k1; //이 경우 k4 객체가 먼저 만들어지고, 이후 k1의 모든 멤버 변수를 복사
```
- 인자를 한 개 받는 기타 생성자 : ==타입 변환 생성자==
```cpp
Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

--------------------
	Knight k1 = 1; // 암시적으로 타입 변환 생성자 호출
	Knight k2 = (Knight)2; // 명시적 형변환. 작동은 위와 같음.
```
위처럼 어떤 데이터 타입을 해당 클래스로 형변환할 때마다 호출되는 특별한 생성자가 된다. 근데 이런 캐스팅이 암시적으로 일어나면 혼란스럽기도 하고, 의도치 않은 버그가 발생할 수도 있다.  그래서 암시적 캐스팅을 막고 싶다면 ==explicit== 키워드를 추가하면 된다.
```cpp
explicit Knight(int hp)
{
//쏼라쏼라
}
```

### 상속성
	객체지향의 3가지 특징 : 상속성, 은닉성, 다형성

저번에 TextRPG를 만들 각 직업들을 struct를 통해 만들었었는데, 클래스로 만들어보자.
```cpp
class Knight
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

class Archer
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

class Mage
{
public:
	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};
```
겹치는 코드가 매우 많다. 이걸 간략하게 해결할 순 없을까?

#### 상속 (Inheritance)
```cpp
#include <iostream>

using namespace std;

class Player
{
public:
	Player() { cout << "Player() 기본 생성자 호출" << endl; }
	Player(int hp)
	{
		_hp = hp;
		_atk = 10;
		{ cout << "Player(int) 생성자 호출" << endl; }
	}
	~Player()
	{
		{ cout << "Player 소멸자 호출" << endl; }
	}
	// 멤버 함수 선언
	void Attack() { cout << "Player Attack 호출" << endl; }
	void Move() { cout << "Player Move 호출" << endl; }
	void Die() { cout << "Player Die 호출" << endl; }

public:
	// 멤버 변수
	int _hp;
	int _atk;
};

class Mage : public Player
{
public:

public:
	int _mp;
};
class Knight : public Player
{
public:
	Knight() { cout << "Knight() 기본 생성자 호출" << endl; }
	Knight(int stamina) : Player(100)
	/*
	* 선처리 영역
	* Player 생성자 호출
	*/
	{
		_stamina = stamina;
		{ cout << "Knight(int)생성자 호출" << endl; }
	}
	~Knight()
	{
		{ cout << "Knight 소멸자 호출" << endl; }
	}
	/*
	* 후처리 영역
	* Player 소멸자 호출
	*/

	// 함수 재정의
	void Move() { cout << "Knight Move 호출" << endl; }
public:
	int _stamina;
};

int main()
{
	Knight k1(10);
	k1.Move(); //재정의된 knight의 함수 호출
	k1.Player::Move(); //재정의로 인해 숨겨진 Player의 원본 함수 호출. 쓸일은 거의 없다.

	return 0;
}
```

###  은닉성
	Data Hiding, 캡슐화(Encapsulation). 몰라도 되는 것은 깔끔하게 숨기겠다!

#### 필요성
1. 정말 위험하고 건드리면 안되는 경우
```cpp
#include <iostream>

using namespace std;

// 자동차
// - 핸들
// - 페달
// - 엔진
// - 문
// - 각종 전기선

// 일반 구매자 입장에서 사용하는 것?
// - 핸들/페달/문
// 몰라도 됨 (오히려 건드리면 큰일남)
// - 엔진, 각종 전기선

// public protected private
// - public : 누구한테나 공개. 실컷 사용하세요~
// - protected : 나의 자손들한테만 허락
// - private : 나만 사용할거야. << class Car 내부에서만!

class Car
{
public: // (멤버) 접근지정자
	void MoveHandle() {}
	void PushPedal() {}
	void OpenDoor() {}

	void TurnKey()
	{
		// ....
		RunEngine();
	}
private:
	void DisassembleCar() {} // 차를 분해한다
	void ConnectCircuit() {} // 전기선 연결
protected:
	void RunEngine() {} // 엔진을 구동시킨다

public:
	// 핸들
	// 페달
	// 엔진
	// 문
	// 각종 전기선
};

class SuperCar : public Car // 상속 접근 지정자
{
public:
	void PushRemoteController()
	{
		RunEngine();
	}
};


int main()
{
	SuperCar car;
	car.OpenDoor();
	car.PushRemoteController();

	return 0;
}


```
2. 다른 경로로 접근하길 원하는 경우
```cpp
#include <iostream>

using namespace std;


// public protected private
// - public : 누구한테나 공개. 실컷 사용하세요~
// - protected : 나의 자손들한테만 허락
// - private : 나만 사용할거야. << class Car 내부에서만!

// '캡슐화'
// 연관된 데이터와 함수를 논리적으로 묶어놓은 것
class Berserker
{
public:
	// 사양 : 체력이 50 이하로 떨어지면 버서커 모드 발동 (강해짐)
	int GetHp() { return _hp; }
	void SetHp(int hp)
	{
		_hp = hp;
		if (_hp <= 50)
			SetBerserkerMode();
	}
private:
	void SetBerserkerMode()
	{
		cout << "매우 강해짐!" << endl;
	}

private :
	int _hp = 100;
};

int main()
{
	Berserker b;
	b.SetHp(20);

	return 0;
}
```

#### 상속 접근 지정자
	 다음 세대한테 부모님의 유산을 어떻게 물려줄지?
- `public` : 공개적 상속. 부모님의 유산 설계 그대로 (public -> public, protected -> protected)
- `protected` : 보호받은 상속. 내 자손들한테만 물려줄거야 (public -> protected, protected -> protected)
- `private` : 개인적인 상속. 나만 쓸거야 (public->private, protected ->private)
```cpp
class SuperCar : private Car // 상속 접근 지정자
{
public:
	void PushRemoteController()
	{
		RunEngine();
	}
};

class TestSuperCar : private SuperCar
{
public:
	void Test()
	{
		RunEngine();// 접근 못함. 에러남.
	}
}
```