### 객체지향의 시작
```cpp
#include <iostream>

using namespace std;

class Knight
{
public :
	void Attack();
	void Move(int x, int y);
	void Die();
	
	int hp;
	int atk;
	int posX;
	int posY;
};

int main()
{
	Knight k1;
	Knight k2;
	
	k1.Attack();
	k1.Move(1,2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << atk << endl;
}

void Knight::Move(int x, int y)
{
	posX = x;
	posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	hp = 0;
	cout << "Die" << endl;
}
```

### 생성자와 소멸자
	특별한 멤버함수 2가지
이전 시간에 클래스에서 멤버 함수, 멤버 변수 등을 만들었었다. 그런데 이 멤버 함수 중에서 특별한 친구들 2가지가 있는데, 그들이 바로 생성자와 소멸자이다.

#### 특징
- 생성자는 함수를 오버로딩 하는 것 처럼 여러개 만들 수 있다.
- 소멸자는 한 개만 만들 수 있다.
- 생성자를 명시적(explicit)으로 만들어두지 않으면, 컴파일러가 아무 인자도 받지 않는 생성자를 만드는데 이를 암시적(implicit) 생성자라 한다.
```cpp
#include <iostream>

using namespace std;

//class 는 일종의 설계도
class Knight
{
public:
	// [1] 기본 생성자 (인자가 없음)
	Knight()
	{
		cout << "Knight() 생성자 호출" << endl;
		_hp = 100;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// [2] 복사 생성자 (자기 자신의 클래스 참조 타입을 인자로 받음)
	// (일반적으로 '똑같은' 데이터를 지닌 객체가 생성되길 기대한다)
	Knight(const Knight& knight)
	{
		_hp = knight._hp;
		_atk = knight._atk;
		_posX = knight._posX;
		_posY = knight._posY;
	}

	// [3] 기타 생성자
	// 이 중에서 인자를 1개만 받는 기타 생성자를
	// [타입 변환 생성자]라 한다.
	Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

	// 소멸자
	~Knight()
	{
		cout << "소멸자 호출" << endl;
	}


	// 멤버 함수 선언
	void Attack();
	void Move(int x, int y);
	void Die();

public:
	// 멤버 변수
	int _hp;
	int _atk;
	int _posX;
	int _posY;
};

int main()
{
	Knight k1;

	k1.Attack();
	k1.Move(1, 2);
	k1.Die();

	return 0;
}

void Knight::Attack()
{
	cout << "Attack : " << _atk << endl;
}

void Knight::Move(int x, int y)
{
	_posX = x;
	_posY = y;
	cout << "Move" << endl;
}

void Knight::Die()
{
	_hp = 0;
	cout << "Die" << endl;
}
```

#### 주의사항
- 생성자가 하나라도 명시적으로 만들어져 있으면, 컴파일러는 ==기본 생성자==를 만들지 않는다.
	-  인자를 받는 생성자가 하나 있으면 컴파일러는 기본 생성자를 만들지 않기 때문에, 아무 인자 없이 클래스를 만드는 게 불가능해진다. 이 경우 명시적으로 기본 생성자를 만들어주어야 한다.
- 사실 ==복사 생성자==도 명시적으로 만들어져 있지 않으면 컴파일러가 자동으로 만든다.
	- 단순 변수만 있으면 왜 굳이 명시적으로 만들어야 할까 싶긴 한데, 동적 할당을 배우면 필요가 있어진다고 한다.
```cpp
Knight k2 = Knight(k1);
Knight k3 = k1; //둘 다 같은 방식.

Knight k4;
k4 = k1; //이 경우 k4 객체가 먼저 만들어지고, 이후 k1의 모든 멤버 변수를 복사
```
- 인자를 한 개 받는 기타 생성자 : ==타입 변환 생성자==
```cpp
Knight(int hp)
	{
		cout << "Knight(int) 생성자 호출" << endl;
		_hp = hp;
		_atk = 10;
		_posX = 0;
		_posY = 0;
	}

--------------------
	Knight k1 = 1; // 암시적으로 타입 변환 생성자 호출
	Knight k2 = (Knight)2; // 명시적 형변환. 작동은 위와 같음.
```
위처럼 어떤 데이터 타입을 해당 클래스로 형변환할 때마다 호출되는 특별한 생성자가 된다. 근데 이런 캐스팅이 암시적으로 일어나면 혼란스럽기도 하고, 의도치 않은 버그가 발생할 수도 있다.  그래서 암시적 캐스팅을 막고 싶다면 ==explicit== 키워드를 추가하면 된다.
```cpp
explicit Knight(int hp)
{
//쏼라쏼라
}
```
