### 정수

#### 앞에 signed가 생략된 친구들
	 signed : 부호가 있다!
- `char` : 1 바이트 (-128~127)
- `short` : 2바이트 (-32768~32767)
-  `int` : 4바이트 (-21.4억~21.4억)
- `__int64` : 8바이트 (long long) 

#### unsigned
	c#의 uint 같은 느낌
- ` unsigned char` : 1 바이트 (0~255)
- `unsigned short` : 2바이트 (0~65536)
-  `unsigned int` : 4바이트 (0~42.9억)
- `unsigned __int64` : 8바이트 (long long)

	최적화를 위해 적합한 크기의 정수형 타입을 사용하자.

#### 정수 오버플로우, 언더플로우
- 정수 오버플로우
```cpp
#include <iostream>
using namespace std;

short a = 32767;

int main()
{
    a += 1;
    cout << a << endl;
}
```
32768이 나와야 할 것 같지만, 정수 오버플로우로 인해 다음과 같은 결과가 나온다. 
![[Pasted image 20250704111257.png]]
`short`는 2바이트짜리 정수형 타입이다. 이렇게 32767을 표현하기 위해서는 부호용 비트 빼고 나머지가 전부 1로 표시되어야 한다. 이 상황에서 +1 연산을 하게 되면, 우리의 컴퓨터는 우리의 상식처럼 정수의 더하기를 시행하지 않고, 비트 단위로 연산을 하기 때문에...
![[Pasted image 20250704111352.png]]
![[Pasted image 20250704111547.png]]
요렇게 된다. 언더플로우도 같은 원리이다.