### 정수

#### 앞에 signed가 생략된 친구들
	 signed : 부호가 있다!
- `char` : 1 바이트 (-128~127)
- `short` : 2바이트 (-32768~32767)
-  `int` : 4바이트 (-21.4억~21.4억)
- `__int64` : 8바이트 (long long) 

#### unsigned
	c#의 uint 같은 느낌
- ` unsigned char` : 1 바이트 (0~255)
- `unsigned short` : 2바이트 (0~65536)
-  `unsigned int` : 4바이트 (0~42.9억)
- `unsigned __int64` : 8바이트 (long long)

	최적화를 위해 적합한 크기의 정수형 타입을 사용하자.
	 참고 : 레벨과 같이 양수로만 표현되어야 하는 경우.. unsigned를 활용해야 할까?
	 - 스타일의 차이. ex) 음수인 경우 프로그램을 크래시해서, 버그를 빨리 찾자

#### 정수 오버플로우, 언더플로우
- 정수 오버플로우
```cpp
#include <iostream>
using namespace std;

short a = 32767;

int main()
{
    a += 1;
    cout << a << endl;
}
```
32768이 나와야 할 것 같지만, 정수 오버플로우로 인해 다음과 같은 결과가 나온다. 
![[Pasted image 20250704111257.png]]
`short`는 2바이트짜리 정수형 타입이다. 이렇게 32767을 표현하기 위해서는 부호용 비트 빼고 나머지가 전부 1로 표시되어야 한다. 이 상황에서 +1 연산을 하게 되면, 우리의 컴퓨터는 우리의 상식처럼 정수의 더하기를 시행하지 않고, 비트 단위로 연산을 하기 때문에...
![[Pasted image 20250704111352.png]]
![[Pasted image 20250704111547.png]]
요렇게 된다. 언더플로우도 같은 원리이다.

### 불리언과 실수

#### 불리언
	참/거짓
- true , false
- 사실 `bool`은 그냥 1 바이트 정수에 불과
-  왜 정수랑 따로 있나=> `bool`만 봐도 참/거짓 둘 중 하나라는 것을 알 수 있다. ==(가독성)==

#### 실수(부동소수점)
- `float`
	- 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4 바이트
- `double`
	- 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8 바이트
- 프로그래밍 할 때 부동소수점은 항상 =='근사값'==
- 수가 커질수록 오차 범위도 매우 커짐
- 실수 두개를`==` 으로 비교하는 것은 지양하자.