### 정수

#### 앞에 signed가 생략된 친구들
	 signed : 부호가 있다!
- `char` : 1 바이트 (-128~127)
- `short` : 2바이트 (-32768~32767)
-  `int` : 4바이트 (-21.4억~21.4억)
- `__int64` : 8바이트 (long long) 

#### unsigned
	c#의 uint 같은 느낌
- ` unsigned char` : 1 바이트 (0~255)
- `unsigned short` : 2바이트 (0~65536)
-  `unsigned int` : 4바이트 (0~42.9억)
- `unsigned __int64` : 8바이트 (long long)

	최적화를 위해 적합한 크기의 정수형 타입을 사용하자.
	 참고 : 레벨과 같이 양수로만 표현되어야 하는 경우.. unsigned를 활용해야 할까?
	 - 스타일의 차이. ex) 음수인 경우 프로그램을 크래시해서, 버그를 빨리 찾자

#### 정수 오버플로우, 언더플로우
- 정수 오버플로우
```cpp
#include <iostream>
using namespace std;

short a = 32767;

int main()
{
    a += 1;
    cout << a << endl;
}
```
32768이 나와야 할 것 같지만, 정수 오버플로우로 인해 다음과 같은 결과가 나온다. 
![[Pasted image 20250704111257.png]]
`short`는 2바이트짜리 정수형 타입이다. 이렇게 32767을 표현하기 위해서는 부호용 비트 빼고 나머지가 전부 1로 표시되어야 한다. 이 상황에서 +1 연산을 하게 되면, 우리의 컴퓨터는 우리의 상식처럼 정수의 더하기를 시행하지 않고, 비트 단위로 연산을 하기 때문에...
![[Pasted image 20250704111352.png]]
![[Pasted image 20250704111547.png]]
요렇게 된다. 언더플로우도 같은 원리이다.

### 불리언과 실수

#### 불리언
	참/거짓
- true , false
- 사실 `bool`은 그냥 1 바이트 정수에 불과
-  왜 정수랑 따로 있나=> `bool`만 봐도 참/거짓 둘 중 하나라는 것을 알 수 있다. ==(가독성)==

#### 실수(부동소수점)
- `float`
	- 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4 바이트
- `double`
	- 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8 바이트
- 프로그래밍 할 때 부동소수점은 항상 =='근사값'==
- 수가 커질수록 오차 범위도 매우 커짐
- 실수 두개를`==` 으로 비교하는 것은 지양하자.

### 문자와 문자열
	 char : 알파벳 / 숫자 문자를 나타낸다
	 wchar_t : 유니코드 문자를 나타낸다
#### Char
```cpp
char ch = 'a';
char ch2 = '1';
char ch3 = 'a'+1; //결과물 출력하면 b
```
- ASCII (American Standard Code for Information Interchange)
- 문자라는 의미로 작은 따옴표 ' ' 사용
- 하지만 현대사회는 알파벳과 숫자만으로 모든 걸 표현할 수 없죠 => 유니코드

#### whcar_t
```cpp
wchar_t wch = L'똥'; //L은 유니코드로 캐스팅한다는 의미
```
- 유니코드
	- 표기 방식이 여러가지 있는데, 대표적으로 UTF8, UTF16
	- UTF8
		- 알파벳, 숫자 1 바이트(ASCII 동일한 번호)
		- 유럽 지역의 문자 2 바이트
		- 한글, 한자 3 바이트
	- UTF16
		- 알파벳, 숫자, 한글, 한자 등 거의 대부분 문자 2 바이트
		- 아주 매우 대단히 예외적인 고대 문자만  4 바이트 (사실상 무시해도 됨)
- Escape Sequence
	- 표기하기 애매한 애들을 표현
	- `\t` = 아스키코드9 = Tab
	- `\n` = 아스키코드10 = LineFeed (한 줄 아래로)
	- `\r` = 아스키코드13 = CarriageReturn (커서를 맨 처음으로)

#### 문자열
	문자들이 열을 지어서 모여 있는 것. 문자 배열..?
```cpp
char str[] = {'h', 'e', 'l', 'l', 'o', '\0'} ; //0이 없으면 0 나올때까지 메모리를 뒤짐
char str1[] = "Hello World" ; //디버그로 찍어보면 끝에 자동으로 0이 포함되어있음
```