![[Pasted image 20250806125557.png]]
예전에 메모리 구조에 대해 간략하게 배운 적이 있다. 나머지는 다 뭔지 아는데, 아직 베우지 않은 부분이 있는데 바로 '힙' 영역이다.

지금까지 '힙' 영역을 쓰지 않고 잘 살아왔는데, 왜 또 새로운 영역을 공부해야 하느냐?
- 예) 500의 동시 접속 유저들이 있고, 유저당 10000마리의 몬스터가 필요한 상황
```cpp
#include <iostream>
using namespace std;

class Monster
{
public:
    int _hp;
    int _x;
    int _y;
};

int main() {
    Monster monsters[500 * 10000];
    return 0;
}
```
![[Pasted image 20250806130011.png]]
이렇게 메인 함수 안에 지역변수로 만들어버리면 바로 스택 오버플로우가 발생한다. 애초에 스택 메모리는 함수에 인자들을 원활하게 전달하기 위한 용도라서 크기가 크지 않다. 
물론 이를 전역 변수로 빼두면 데이터 영역에 저장되기 때문에 스택 오버플로우 문제는 해결되긴 한다. 하지만 유저가 늘 500명이 동시 접속한 상황인 것도 아니고, 그렇다면 저렇게 늘 엄청난 크기의 배열이 메모리를 계속 차지하는 것은 비효율적이라고 볼 수 있다.

여기서 새로운 메모리 영역의 필요성이 대두되는데, 다음과 같은 기대를 충족시켜준다.
- 필요할 때만 사용하고, 필요 없으면 반납 가능
- 스택과 달리 우리가 생성/소멸 시점을 관리할 수 있다.
이것이 바로 =='힙' (HEAP)== 영역이다.
	 동젹할당 관련 연산자 : `malloc, free/ new, delete/ new[], delete[]`

#### 동적할당 관련 연산자
- `malloc`
	- 할당할 메모리 크기를 건네준다
	- 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다. (메모리 부족 시 nullptr 반환)
```cpp
void* pointer = malloc(1000);
```

	- void* ?? 이건 뭘까
		- * 가 있으니 포인터는 맞다.
		- 타고 가면 void. 뭐가 있는지 모르겠으니 알아서 써라. 라는 뜻.

- `free`
	-  malloc (혹은 기타 calloc, realloc 등의 사촌) 을 통해 할당된 영역을 해제
	- 힙 관리자가 할당/미할당 여부를 구분해서 관리
```cpp
#include <iostream>
using namespace std;

class Monster
{
public:
    int _hp;
    int _x;
    int _y;
};

int main() {
    // 유저 영역 [메모장] [LOL] [곰플레이어]
    // --------------------------------
    // 커널 영역 (Windows 등의 핵심 코드)

    // 우저 영역) 운영체제에서 제공하는 API 호출
    // 커널 영역) 메모리 할당해서 건내줌
    // 유저 영역) ㄳㄳ 잘 쓸게요~

    // C++에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
    // 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 풀링)
    Monster* m1 = (Monster*)malloc(sizeof(Monster));
    m1->_hp = 100;
    m1->_x = 1;
    m1->_y = 2;
    // Heap Overflow
    // 유효한 힙 범위를 초과해서 사용하는 문제 (위에서 sizeof 하지 않고 4를 넣어봐)
    
    // 만약에 free 하지 않으면 메모리 누수
	free(m1);
	
	// Double free
	// 대부분 크래시만 나고 끝난다
	free(m1);
	
	// Use-After-Free
	// - 프로그래머 입장 : OMG 망했다!
	// - 해커 입장 : 심봤다!
	m1->_hp = 100;
	m1->_x = 1;
	m1->_y = 2;
	
    return 0;
}
```

- new / delete
	- C++에 추가됨
	- ==malloc/free는 함수! new/delete는 연산자!==
	- new/delete 는 생성타입이 ==클래스==일 경우, ==생성자/소멸자를 호출해준다!==

```cpp
	Monster* m2 = new Monster;
	delete m2;

	Monster* m3 = new Monster[5]; // 몬스터 5마리 만큼의 크기를 가진 배열을 할당해줌
	delete[] m3;
```