![[Pasted image 20250806125557.png]]
예전에 메모리 구조에 대해 간략하게 배운 적이 있다. 나머지는 다 뭔지 아는데, 아직 베우지 않은 부분이 있는데 바로 '힙' 영역이다.

지금까지 '힙' 영역을 쓰지 않고 잘 살아왔는데, 왜 또 새로운 영역을 공부해야 하느냐?
- 예) 500의 동시 접속 유저들이 있고, 유저당 10000마리의 몬스터가 필요한 상황
```cpp
#include <iostream>
using namespace std;

class Monster
{
public:
    int _hp;
    int _x;
    int _y;
};

int main() {
    Monster monsters[500 * 10000];
    return 0;
}
```
![[Pasted image 20250806130011.png]]
이렇게 메인 함수 안에 지역변수로 만들어버리면 바로 스택 오버플로우가 발생한다. 애초에 스택 메모리는 함수에 인자들을 원활하게 전달하기 위한 용도라서 크기가 크지 않다. 
물론 이를 전역 변수로 빼두면 데이터 영역에 저장되기 때문에 스택 오버플로우 문제는 해결되긴 한다. 하지만 유저가 늘 500명이 동시 접속한 상황인 것도 아니고, 그렇다면 저렇게 늘 엄청난 크기의 배열이 메모리를 계속 차지하는 것은 비효율적이라고 볼 수 있다.

여기서 새로운 메모리 영역의 필요성이 대두되는데, 다음과 같은 기대를 충족시켜준다.
- 필요할 때만 사용하고, 필요 없으면 반납 가능
- 스택과 달리 우리가 생성/소멸 시점을 관리할 수 있다.
이것이 바로 =='힙' (HEAP)== 영역이다.
	 동젹할당 관련 연산자 : `malloc, free/ new, delete/ new[], delete[]`

#### 동적할당 관련 연산자
- `malloc`
	- 할당할 메모리 크기를 건네준다
	- 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다. (메모리 부족 시 nullptr 반환)
```cpp
void* pointer = malloc(1000);
```

	- void* ?? 이건 뭘까
		- * 가 있으니 포인터는 맞다.
		- 타고 가면 void. 뭐가 있는지 모르겠으니 알아서 써라. 라는 뜻.

- `free`
	-  malloc (혹은 기타 calloc, realloc 등의 사촌) 을 통해 할당된 영역을 해제
	- 힙 관리자가 할당/미할당 여부를 구분해서 관리
```cpp
#include <iostream>
using namespace std;

class Monster
{
public:
    int _hp;
    int _x;
    int _y;
};

int main() {
    // 유저 영역 [메모장] [LOL] [곰플레이어]
    // --------------------------------
    // 커널 영역 (Windows 등의 핵심 코드)

    // 우저 영역) 운영체제에서 제공하는 API 호출
    // 커널 영역) 메모리 할당해서 건내줌
    // 유저 영역) ㄳㄳ 잘 쓸게요~

    // C++에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
    // 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 풀링)
    Monster* m1 = (Monster*)malloc(sizeof(Monster));
    m1->_hp = 100;
    m1->_x = 1;
    m1->_y = 2;
    // Heap Overflow
    // 유효한 힙 범위를 초과해서 사용하는 문제 (위에서 sizeof 하지 않고 4를 넣어봐)
    
    // 만약에 free 하지 않으면 메모리 누수
	free(m1);
	
	// Double free
	// 대부분 크래시만 나고 끝난다
	free(m1);
	
	// Use-After-Free
	// - 프로그래머 입장 : OMG 망했다!
	// - 해커 입장 : 심봤다!
	m1->_hp = 100;
	m1->_x = 1;
	m1->_y = 2;
	
    return 0;
}
```

- new / delete
	- C++에 추가됨
	- ==malloc/free는 함수! new/delete는 연산자!==
	- new/delete 는 생성타입이 ==클래스==일 경우, ==생성자/소멸자를 호출해준다!==

```cpp
	Monster* m2 = new Monster;
	delete m2;

	Monster* m3 = new Monster[5]; // 몬스터 5마리 만큼의 크기를 가진 배열을 할당해줌
	delete[] m3;
```

### 타입변환
	 malloc : void*형 포인터를 반환. 타입변환을 통해 알아서 쓴다. 이 타입변환에 대해 자세히 알아보자.

```cpp
#include <iostream>
			using namespace std;

		class Knight
		{
		public:
			int _hp = 100;
		};

		class Dog
		{
		public:
			Dog()
			{

			}
			// 타입 변환 생성자
			Dog(const Knight& knight)
			{
				_age = knight._hp;
			}

			// 타입 변환 연산자
			operator Knight()
			{
				return (Knight)(*this);
			}
		public:
			int _age = 10;
			int _cuteness = 20;
		};

		class BullDog : public Dog
		{
		public:
			bool _french;
		};

		int main() {
			// ------------------- 타입 변환 유형 (비트열 재구성 여부)----------------------
			// [1] 값 타입 변환
			// 특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성
			{
				int a = 123456789; // 2의 보수
				float b = (float)a; // 부동소수점(지수 + 유효숫자)
			}

			// [2] 참조 타입 변환
			// 특징) 비트열을 재구성하지 않고, '관점'만 바꾸는 것.
			// 거의 쓸일은 없지만, 포인터 타입 변환도 '참조 타입 변환'과 동일한 룰을 따른다.
			{
				int a = 123456789;
				float b = (float&)a;
			}

			// ------------------- 안전도 분류 ----------------------

			// [1] 안전한 변환
			// 특징) 의미가 항상 100% 완전히 일치하는 경우
			// 같은 타입이면서 크기만 더 큰 바구니로 이동
			// 작은 바구니 -> 큰 바구니로 이동 OK(업캐스팅)
			// ex) char -> short, short -> int, int -> _int64
			{
				int a = 123456789;
				__int64 b = (__int64)b;
			}

			// [2] 불안전한 변환
			// 특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우
			// 타입이 다르거나
			// 같은 타입이지만 큰 바구니 -> 작은 바구니 이동 (다운캐스팅)
			{
				int a = 123456789;
				float b = a;
				short c = a;
			}

			// ------------------- 프로그래머 의도에 따라 분류 ----------------------

			// [1] 암시적 변환
			// 특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러가 '자동'으로 타입 변환
			{
				int a = 123456789;
				float b = a;
			}

			// [2] 명시적 변환
			// 특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러가 '자동'으로 타입 변환
			{
				int a = 123456789;
				int* b = (int*)a;
			}

			// ------------------- 아무런 연관이 없는 클래스 사이의 변환 ----------------------

			// [1] 연관없는 클래스 사이의 '값 타입' 변환
			// 특징) 일반적으로 안됨. (예외 : 타입 변환 생성자, 타입 변환 연산자)
			{
				Knight knight;
				Dog dog = Dog(knight);
				Knight knight2 = dog;
			}

			//[2] 연관없는 클래스 사이의 참조 타입 변환
			// 특징) 명시적으로는 OK
			{
				Knight knight;
				// 어셈블리어 관점 : 포인터 = 참조

				// [주소] -> [Dog]
				Dog& dog = (Dog&)knight;
				dog._cuteness = 12;
			}

			// ------------------- 상속 관계에 있는 클래스 사이의 변환 ----------------------
			// 특징) 자식->부모 OK    /    부모->자식 NO
			// [1] 상속 관계 클래스의 값 타입 변환
			{
				// 이건 안됨
				//Dog dog;
				//BullDog bullDog = (BullDog)dog;

				BullDog bullDog;
				Dog dog = bullDog;
			}
			// [2] 상속 관계 클래스의 참조 타입 변환
			// 특징) 자식->부모 OK	/   부모->자식 명시적으로만 OK
			{
				Dog dog;
				BullDog& bulldog = (BullDog&)dog;

				BullDog bulldog2;
				Dog& doge = bulldog2;
			}


			// 결론)
			// [값 타입 변환] : 진짜 비트열도 바꾸고~ 논리적으로 말이 되게 변환
			// - 논리적으로 말이 된다? (ex. BullDog -> Dog) ok
			// - 논리적으로 말이 안된다 (ex. Dog->BullDog, Dog->Knight) 안됨
			// [참조 타입 변환] : 비트열은 냅두고 우리의 '관점'만 바꾸는 변환
			// - 땡깡 부리면(명시적 요구) 해주긴 하는데, 말 안해도 '그냥' (암시적)으로 해주
			     //는지는 안정성 여부와 연관 있음
			// -- 안전하다? (ex. BullDog->Dog&) '그냥'(암시적으로) OK
			// -- 위험하다? (ex. Dog->BullDog&)
			// --- 메모리 침범 위험이 있는 경우는 '그냥'(암시적으로) 해주진 않음(위험하니까)
			// --- 명시적으로 정말 정말 하겠다고 최종 서명을 하면 OK
			return 0;
		};
		
```

#### 포인터 타입 변환
- 복습
``` cpp
#include <iostream>
using namespace std;


class Item
{
public:
	Item()
	{
		cout << "Item()" << endl;
	}

	Item(const Item& item)
	{
		cout << "Item(const Item&)" << endl;
	}

	~Item()
	{
		cout << "~Item()" << endl;
	}

public:
	int _itemType = 0;
	int _itemDbId = 0;

	char _dummy[4096] = {}; // 이런저런 정보들로 인해 비대해진
};

void TestItem(Item item)
{

}

void TestItemPtr(Item* item)
{

}

int main() 
{
	// 복습
	{
		// Stack [type(4) dbid(4) dummy(4096)]
		Item item;

		// Stack[ 주소(4~8) ] -> Heap [type(4) dbid(4) dummy(4096)]
		Item* item2 = new Item();

		TestItem(item);
		TestItem(*item2);

		TestItemPtr(&item);
		TestItemPtr(item2);

		// 누락 시 메모리 누수(Memory Leak) -> 점점 가용 메모리가 줄어들어서 Crash
		delete item2;
	}

	// 배열
	{
		cout << "-----------------------------------------" << endl;

		// 진짜 아이템이 100개 있는 것 (스택 메모리에 올라와 있는)
		Item item3[100] = {};

		cout << "-----------------------------------------" << endl;

		// 아이템이 100개 있을까요?
		// 아이템을 가리키는 바구니가 100개. 실제 아이템은 1개도 없을 수도 있음.
		Item* item4[100] = {};

		for (int i = 0; i < 100; i++)
			item4[i] = new Item();

		for (int i = 0; i < 100; i++)
			delete item4[i];
		cout << "-----------------------------------------" << endl;
	}
	return 0;
};


```

- 포인터 타입 변환
```cpp
#include <iostream>
using namespace std;

class Knight
{
public:
	int _hp = 0;
};

class Item
{
public:
	Item()
	{
		cout << "Item()" << endl;
	}

	Item(int type) : _itemType(type)
	{
		cout << "Item(int)" << endl;
	}

	Item(const Item& item)
	{
		cout << "Item(const Item&)" << endl;
	}

	virtual ~Item()
	{
		cout << "~Item()" << endl;
	}

public:
	int _itemType = 0;
	int _itemDbId = 0;

	char _dummy[4096] = {}; // 이런저런 정보들로 인해 비대해진
};

enum ItemType
{
	IT_WEAPON = 1,
	IT_ARMOR = 2,
};

class Weapon : public Item
{
public:
	Weapon() : Item(IT_WEAPON)
	{
		cout << "Weapon()" << endl;
		_atk = rand() % 100;
	}

	~Weapon()
	{
		cout << "~Weapon()" << endl;
	}
public:
	int _atk;
};

class Armor : public Item
{
public:
	Armor() : Item(IT_ARMOR), _def(0)
	{
		cout << "Armor()" << endl;
	}

	~Armor()
	{
		cout << "~Armor()" << endl;
	}
public:
	int _def;
};


void TestItem(Item item)
{

}

void TestItemPtr(Item* item)
{

}

int main() 
{
	// 연관성이 없는 클래스 사이의 포인터 변환 테스트
	{
		 // Stack [ 주소 ] -> Heap [ _hp(4) ]
		Knight* knight = new Knight();

		// 암시적으로는 NO
		// 명시적으로는 OK
		// Stack [ 주소 ]
		/*Item* item = (Item*)knight;
		item->_itemType = 2;
		item->_itemDbId = 1;*/

		delete knight;
	}

	// 자식 -> 부모 변환 테스트
	{
		Item* item = new Item();

		// [ [item] ]
		// [  _atk  ]
		/*Weapon* weapon = (Weapon*)item;
		weapon->_atk = 10;*/
		delete item;
	}

	// 부모 -> 자식 변환 테스트
	{
		Weapon* weapon = new Weapon();

		// 암시적으로도 된다!
		Item* item = weapon;

		delete weapon;
	}

	// 명시적으로 타입 변환할 때는 항상 항상 조심해야 한다!
	// 암시적으로 될 때는 안전하다?
	// -> 평생 명시적으로 타입 변환(캐스팅)은 안 하면 되는거 아닌가?

	Item* inventory[20] = {};

	srand((unsigned int)time(nullptr));
	for (int i = 0; i < 20; i++)
	{
		int randValue = rand() % 2; // 0~1
		switch (randValue)
		{
		case 0:
			inventory[i] = new Weapon();
			break;
		case 1:
			inventory[i] = new Armor();
			break;
		}
	}
	for (int i = 0; i < 20; i++)
	{
		Item* item = inventory[i];
		if (item == nullptr)
			continue;

		if (item->_itemType == IT_WEAPON)
		{
			Weapon* weapon = (Weapon*)item;
			cout << "Weapon Atk : " << weapon->_atk << endl;
		}
	}
	// ******************** 매우 매우 매우 중요 ********************
	for (int i = 0; i < 20; i++)
	{
		Item* item = inventory[i];
		if (item == nullptr)
			continue;

		//delete item; <------------ virtual 없이 이러면 자식 소멸자 호출 안됨!!!!!(메모리 누수)

		/*
		근데 이건 너무 귀찮지 않나?
		if (item->_itemType == IT_WEAPON)
		{
			Weapon* weapon = (Weapon*)item;
			delete weapon;
		}
		else if (item->_itemType == IT_ARMOR)
		{
			Armor* armor = (Armor*)item;
			delete armor;
		}
		*/
		// item 소멸자에 virtual을 붙여라.
		delete item;
	}

	// [결론]
	// - 포인터 vs 일반 타입 : 차이를 이해하자
	// - 포인터 사이의 타입 변환(캐스팅)을 할 때는 매우 매우 조심해야 한다!
	// - 부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지 말고 무조건 virtual을 붙이자!!!

	return 0;
};


```

### 얕은 복사 vs 깊은 복사
	중요. 면접 단골 주제.

```cpp
#include <iostream>
using namespace std;

class Pet
{
public:
	Pet()
	{
		cout << "Pet()" << endl;
	}
	~Pet()
	{
		cout << "~Pet()" << endl;
	}
	Pet(const Pet& pet)
	{
		cout << "Pet(const Pet&)" << endl;
	}
};

class Knight
{
public:
	Knight()
	{
		_pet = new Pet();
	}
	Knight(const Knight& knight)
	{
		_hp = knight._hp;
		_pet = new Pet(*knight._pet); // 깊은 복사
	}
	Knight& operator=(const Knight& knight)
	{
		_hp = knight._hp;
		_pet = new Pet(*knight._pet); // 깊은 복사
		return *this;
	}
	~Knight()
	{
		delete _pet;
	}

public:
	int _hp = 100;
	Pet* _pet;
};

int main() 
{
	Pet* pet = new Pet();
	Knight knight; // 기본 생성자
	knight._hp = 200;
	knight._pet = pet;

	Knight knight2 = knight; // 복사 생성자
	//Knight knight3(knight);

	Knight knight3; // 기본 생성자
	knight3 = knight; // 복사 대입 연산자

	// [복사 생성자] + [복사 대입 연산자]
	// 둘 다 안 만들어주면 컴파일러가 '암시적으로' 만들어준다

	// 편하니까 그냥 넘어가자? <-- NO
	// 가끔 직접 만들어야 할 때가 있다.

	// [ 얕은 복사 Shallow Copy]
	// 멤버 데이터를 비트열 단위로 '똑같이' 복사 (메모리 영역 값을 그대로 복사)
	// 포인터는 주소 값 그대로 복사 -> 동일한 객체를 가리키는 상태가 됨.

	// [ 깊은 복사 Deep Copy]
	// 멤버 데이터가 참조(주소) 값이라면, 데이터를 새로 만들어준다 (원본 객체가 참조하는 대상까지 새로 만들어서 복사)

	return 0;
};


```