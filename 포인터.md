### 포인터 기초
	포인터 : 주소를 저장하는 바구니
	4바이트(32비트) or 8바이트(64비트) 고정 크기

- TYPE* 변수이름
```cpp
	int number = 1;
	
	int* ptr = &number;
```

- * 변수이름 = 값
	앞에 * 붙어있으면 포탈 타고 순간이동 한다고 생각하자.
```cpp
	int value1 = *ptr;
	*ptr = 2;
```

결국 포인터란 주소를 저장하는 바구니인데, 타입은 왜 붙이는 걸까?
	주소에 가면 뭐가 있는지 알려주는 역할
	ex) 결혼식 청첩장에 있는 주소 = 예식장 주소
	ex) 명함에 있는 주소 = 회사 주소

### 포인터 연산
	1. 주소 연산자 (&)
	2. 산술 연산자 (+ -)
	3. 간접 연산자 (*)
	4. 간접 멤버 연산자 (->)
```cpp
#include <iostream>
using namespace std;

struct Player
{
	int hp;
	int damage;
};

int main()
{
	int number = 1;

	// 1) 주소 연산자 (&)
	// - 해당 변수의 주소를 알려주세요~
	// - 더 정확히 말하면 해당 변수 타입(TYPE)에 따라서 TYPE* 반환
	int* pointer = &number;

	// 2) 산술 연산자 (+ -)

	number += 1; // 1 증가했다.

	pointer += 1; // 4 증가했다 (?)
	// [!] 포인터에서 + 나 - 등 산술 연산으로 1을 더하거나 빼면.
	// 정말 그 숫자를 더하고 빼라는 의미가 아니다.
	// 한번에 그 TYPE의 크기만큼 이동하라!
	// int형 크기 4바이트
	// 다음 바구니로 이동하라!

	// 3) 간접 연산자 (*)
	// - 포탈을 타고 해당 주소로 슝~ 이동
	number = 3;
	*pointer = 3;

	Player player;
	player.hp = 100;
	player.damage = 10;

	Player* playerPtr = &player;

	(*playerPtr).hp = 200;
	(*playerPtr).damage = 200;

	// 4) 간접 멤버 연산자 (->)
	// 바로 위에서 한 *와 .을 한방에!
	playerPtr->hp = 200;
	playerPtr->damage = 200;

	return 0;
}
```

### 포인터 실습
```cpp
#include <iostream>
using namespace std;

struct StatInfo
{
	int hp; // +0
	int atk; // +4
	int def; // +8 (주소 오프셋)
};

void EnterLobby();
StatInfo CreatePlayer();

void CreateMonster(StatInfo* info);


int main()
{
	EnterLobby();

	return 0;
}

void EnterLobby()
{
	cout << "로비에 입장했습니다" << endl;
	StatInfo player;
	player = CreatePlayer();
	
	StatInfo monster;

	CreateMonster(&monster);
}

StatInfo CreatePlayer()
{
	StatInfo ret;
	
	cout << "플레이어 생성" << endl;

	ret.hp = 100;
	ret.atk = 10;
	ret.def = 2;

	return ret;
}

void CreateMonster(StatInfo* info)
{
	cout << "몬스터 생성" << endl;

	info->hp = 40;
	info->atk = 8;
	info->def = 1;
}

```

### 참조 기초
	포인터와 아주 밀접한 관련이 있다.
```cpp
	int number = 1;
	int& reference = number; // 참조
```
- 로우 레벨(어셈블리) 관점에서 보면 작동 방식이 포인터와 같다.
- C++ 관점에서 보면, number라는 바구니에 reference라는 이름을 또 지어준 것.
	- 앞으로 reference에서 뭘 꺼내거나 넣으면, number에다가 할게~

### 포인터 vs 참조
	둘은 어셈블리어 관점에서 보면 정말 똑같이 작동한다. 그렇다면 각각 어떤 차이점이 있을까?
#### 1. 편의성
- 함수에 매개변수를 넘겨줄 때, 쓸데없이 지역변수를 만들고 값을 복사하는 과정을 방지하기 위해 포인터나 참조를 사용하곤 한다.
```cpp
struct info
{
	int hp = 1;
	int atk = 5;
}

int main()
{
	info player;
	PrintByPtr(&player);
	PrintByRef(player);
}
....

void PrintByPtr(info* player)
{
	cout << player->hp << endl;
}

void PrintByRef(info& player)
{
	cout << player.hp << endl;
}
```
- 위 예제를 보면 알 수 있듯이 참조를 통해 넘기면 멤버에 접근할 때 .만 찍으면 되니, ->로 접근해야 하는 포인터보다 좀 더 편하긴 하다.
- <span style="background:#ff4d4f">편하다고 다 좋은 것은 아닌게, 원본에 접근한다는 것을 잊은 채 수정하면 안되는 것을 바꿔버리는 경우가 있다.</span>
- 그럴 땐 const 키워드를 활용하자.
	- 참고로 포인터도 const 키워드를 활용할 수 있는데, 별의 앞에 오느냐 뒤에 오느냐에 따라 주소가 고정되느냐 값이 고정되느냐가 달라진다.
```cpp
void PrintByRef(const info& player)
{
	cout << player.hp << endl;
	player.hp = 100; //아마 에러가 날 것이다.
}

void PrintByPtr(const info* player) // 값 고정
{
	cout << player->hp << endl;
}

void PrintByPtr(info* const player) // 주소 고정
{
	cout << player->hp << endl;
}

void PrintByPtr(const info* const player) // 둘다 고정
{
	cout << player->hp << endl;
}
```

#### 2. 초기화
- 포인터는 초기화가 필요 없다. nullPtr이라는 게 있기 때문.
- 다만 <span style="background:#fff88f">참조</span>는 원래 있던 바구니에 또 다른 이름을 지어주는 것이기 때문에, <span style="background:#fff88f">초기화가 반드시 필요</span>하다.
```cpp
int num = 1;
int* ptr = nullPtr;
int& ref = num;
```

#### 보너스
- 참조를 포인터로 부를 때 : 주소를 넘겨라.
```cpp
info& ref = player;
PrintByPtr(&ref);
```
- 포인터를 참조로 넘길 때 : * 붙여서 값을 넘겨라.
```cpp 
info* ptr = &player;
PrintByRef(*ptr);
```
