### 포인터 기초
	포인터 : 주소를 저장하는 바구니
	4바이트(32비트) or 8바이트(64비트) 고정 크기

- TYPE* 변수이름
```cpp
	int number = 1;
	
	int* ptr = &number;
```

- * 변수이름 = 값
	앞에 * 붙어있으면 포탈 타고 순간이동 한다고 생각하자.
```cpp
	int value1 = *ptr;
	*ptr = 2;
```

결국 포인터란 주소를 저장하는 바구니인데, 타입은 왜 붙이는 걸까?
	주소에 가면 뭐가 있는지 알려주는 역할
	ex) 결혼식 청첩장에 있는 주소 = 예식장 주소
	ex) 명함에 있는 주소 = 회사 주소

### 포인터 연산
	1. 주소 연산자 (&)
	2. 산술 연산자 (+ -)
	3. 간접 연산자 (*)
	4. 간접 멤버 연산자 (->)
```cpp
#include <iostream>
using namespace std;

struct Player
{
	int hp;
	int damage;
};

int main()
{
	int number = 1;

	// 1) 주소 연산자 (&)
	// - 해당 변수의 주소를 알려주세요~
	// - 더 정확히 말하면 해당 변수 타입(TYPE)에 따라서 TYPE* 반환
	int* pointer = &number;

	// 2) 산술 연산자 (+ -)

	number += 1; // 1 증가했다.

	pointer += 1; // 4 증가했다 (?)
	// [!] 포인터에서 + 나 - 등 산술 연산으로 1을 더하거나 빼면.
	// 정말 그 숫자를 더하고 빼라는 의미가 아니다.
	// 한번에 그 TYPE의 크기만큼 이동하라!
	// int형 크기 4바이트
	// 다음 바구니로 이동하라!

	// 3) 간접 연산자 (*)
	// - 포탈을 타고 해당 주소로 슝~ 이동
	number = 3;
	*pointer = 3;

	Player player;
	player.hp = 100;
	player.damage = 10;

	Player* playerPtr = &player;

	(*playerPtr).hp = 200;
	(*playerPtr).damage = 200;

	// 4) 간접 멤버 연산자 (->)
	// 바로 위에서 한 *와 .을 한방에!
	playerPtr->hp = 200;
	playerPtr->damage = 200;

	return 0;
}
```

### 포인터 실습
```cpp
#include <iostream>
using namespace std;

struct StatInfo
{
	int hp; // +0
	int atk; // +4
	int def; // +8 (주소 오프셋)
};

void EnterLobby();
StatInfo CreatePlayer();

void CreateMonster(StatInfo* info);


int main()
{
	EnterLobby();

	return 0;
}

void EnterLobby()
{
	cout << "로비에 입장했습니다" << endl;
	StatInfo player;
	player = CreatePlayer();
	
	StatInfo monster;

	CreateMonster(&monster);
}

StatInfo CreatePlayer()
{
	StatInfo ret;
	
	cout << "플레이어 생성" << endl;

	ret.hp = 100;
	ret.atk = 10;
	ret.def = 2;

	return ret;
}

void CreateMonster(StatInfo* info)
{
	cout << "몬스터 생성" << endl;

	info->hp = 40;
	info->atk = 8;
	info->def = 1;
}

```